import { GoogleGenAI, Type } from "@google/genai";

// Helper to get client with current env key
const getClient = () => {
    const apiKey = process.env.API_KEY;
    if (!apiKey) {
        throw new Error("API Key not found. Please select a key via the AI Studio button.");
    }
    return new GoogleGenAI({ apiKey });
};

// --- Helpers ---

const fileToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            const result = reader.result as string;
            resolve(result.split(',')[1]);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
};

const blobToBase64 = (blob: Blob): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            const result = reader.result as string;
            // Handle both data url formats (with and without prefix) just in case
            resolve(result.split(',')[1] || result);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
};

const extractImageFromResponse = (response: any): Blob => {
    let base64Data: string | undefined;

    // Search for the image part in the response
    if (response.candidates && response.candidates[0].content.parts) {
        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData) {
                base64Data = part.inlineData.data;
                break;
            }
        }
    }

    if (!base64Data) {
        throw new Error("No image generated by the AI.");
    }

    const byteCharacters = atob(base64Data);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: 'image/png' });
};

// --- Main Exported Functions ---

export const generateStickerLabels = async (imageFile: File): Promise<string[]> => {
    const ai = getClient();
    const base64Data = await fileToBase64(imageFile);
    
    const systemPrompt = `
        Analyze this image, which is a 4x4 grid of stickers (16 total).
        Provide a short, descriptive filename for each sticker in the grid.
        Read the grid from left to right, top to bottom.
        The format should be kebab-case (e.g., "anime-girl-happy", "chibi-wink-peace").
        Focus on the emotion, action, or key object. Keep it under 4 words.
        Do not include file extensions.
        Return ONLY a JSON array of strings.
    `;

    const makeRequest = async (modelName: string) => {
        return await ai.models.generateContent({
            model: modelName,
            contents: {
                parts: [
                    { inlineData: { mimeType: imageFile.type, data: base64Data } },
                    { text: systemPrompt }
                ]
            },
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.ARRAY,
                    items: { type: Type.STRING }
                }
            }
        });
    };

    let response;
    try {
        // Try latest Gemini 3 model
        response = await makeRequest('gemini-3-flash-preview');
    } catch (error: any) {
        console.warn("Gemini 3 Flash failed, attempting fallback.", error);
        // Fallback to Gemini 2.5
        response = await makeRequest('gemini-2.5-flash-latest');
    }

    const jsonText = response.text;
    if (!jsonText) throw new Error("No data returned from AI");
    
    try {
        const labels = JSON.parse(jsonText);
        return Array.isArray(labels) ? labels : Array(16).fill("sticker");
    } catch (e) {
        return Array(16).fill("sticker");
    }
};

export const generateStickerSheet = async (
    prompt: string, 
    subjectImage?: File | null, 
    styleImage?: File | null
): Promise<Blob> => {
    const ai = getClient();
    
    // Base prompt construction
    let fullPrompt = `Create a high-quality 4x4 grid sticker sheet containing 16 distinct stickers based on this description: "${prompt}". 
    The output MUST be a perfect 4x4 grid layout with clear spacing between items on a solid white background. 
    Ensure the stickers are completely separate and do not overlap the grid lines. 
    Style: Vector illustration, vibrant colors, clear outlines.`;

    const parts: any[] = [];

    // Attach references if available
    if (subjectImage) {
        fullPrompt += `\n\nREFERENCE INSTRUCTION: Use the attached image labeled 'Subject Reference' as the primary source for the character/object design.`;
        const base64 = await fileToBase64(subjectImage);
        parts.push({ text: "Subject Reference:" });
        parts.push({ inlineData: { mimeType: subjectImage.type, data: base64 } });
    }

    if (styleImage) {
        fullPrompt += `\n\nREFERENCE INSTRUCTION: Use the attached image labeled 'Style Reference' to determine the artistic style.`;
        const base64 = await fileToBase64(styleImage);
        parts.push({ text: "Style Reference:" });
        parts.push({ inlineData: { mimeType: styleImage.type, data: base64 } });
    }

    parts.push({ text: fullPrompt });

    try {
        // Attempt 1: High Quality (Gemini 3 Pro - 4K)
        const response = await ai.models.generateContent({
            model: 'gemini-3-pro-image-preview',
            contents: { parts: parts },
            config: {
                imageConfig: {
                    imageSize: "4K", 
                    aspectRatio: "1:1"
                },
            },
        });
        return extractImageFromResponse(response);

    } catch (error: any) {
        console.warn("Gemini 3 Pro Image failed (Permission/Access), falling back to Gemini 2.5 Flash Image", error);
        
        // Attempt 2: Standard Quality (Gemini 2.5 - 1024x1024)
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: { parts: parts },
            config: {
                imageConfig: {
                    aspectRatio: "1:1"
                },
            },
        });
        return extractImageFromResponse(response);
    }
};

export const regenerateSticker = async (
    originalStickerBlob: Blob,
    modificationPrompt: string
): Promise<Blob> => {
    const ai = getClient();
    const base64Data = await blobToBase64(originalStickerBlob);

    // Prompt engineering to maintain style while applying changes
    const fullPrompt = `
        Modify this input sticker image based strictly on this instruction: "${modificationPrompt}".
        
        CRITICAL STYLE INSTRUCTIONS:
        1. Maintain the exact same art style (Vector illustration, vibrant colors, clear outlines) as the input image.
        2. Keep the character/object consistent, only apply the requested change.
        3. Output MUST be a single sticker element on a clean white background.
        4. Do NOT output a grid, just the single modified sticker.
    `;

    const parts = [
        { inlineData: { mimeType: "image/png", data: base64Data } },
        { text: fullPrompt }
    ];

    try {
        // Using Gemini 2.5 Flash Image for fast editing/regeneration
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: { parts: parts },
            config: {
                imageConfig: {
                    aspectRatio: "1:1"
                },
            },
        });
        return extractImageFromResponse(response);
    } catch (error: any) {
        console.error("Failed to regenerate sticker", error);
        throw error;
    }
};
